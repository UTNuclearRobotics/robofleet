#! /usr/bin/env python3
"""
Utilities for generating Flatbuffers schemas for ROS message types. 

Schema formats documentation:
    http://wiki.ros.org/msg and 
    https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html
"""

from argparse import ArgumentParser
import os
import re
import sys

# from rosbridge_library.internal.ros_loader import get_message_class
from roslib.message import get_message_class

# place all message namespaces within this namespace
BASE_NS = "fbb"

# types that are already defined in Flatbuffers
primitive_types = {
    "bool",
    "int8",
    "int16",
    "int32",
    "int64",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "float32",
    "float64",
    "string",
}
base_defined_types = {
    # all of these Flatbuffers primitives directly correspond to ROS types
    *primitive_types,

    # generated by gen_support()
    "MsgMetadata",
    "RosTime",
    "RosDuration"
}

def gen_metadata_item(*, args):
    """ Generate a table field containing a MsgMetadata. """ 
    yield "  __metadata:{}.MsgMetadata;".format(args.base_namespace)

def gen_support(*, args):
    """ Generate supporting definitions """
    # Namespace everything
    yield "namespace {};".format(args.base_namespace)

    # Metadata table for all messages, to support RoboFleet
    yield "table MsgMetadata {"
    yield "  topic:string;"
    yield "}"

    # All generated messages can be read as MsgWithMetadata to access metadata
    yield "table MsgWithMetadata {"
    yield from gen_metadata_item(args=args)
    yield "}"

    # ROS time primitives
    yield "struct RosTime {"
    yield "  secs:uint32;"
    yield "  nsecs:uint32;"
    yield "}"
    yield "struct RosDuration {"
    yield "  secs:int32;"
    yield "  nsecs:int32;"
    yield "}"

# direct ROS to Flatbuffers type remappings
type_mapping = {
    "time": "RosTime",
    "duration": "RosDuration"
}

def type_remap(ros_type_name):
    """ apply direct translations from ROS type names to flatbuffers type names """
    if ros_type_name in type_mapping:
        return type_mapping[ros_type_name]
    return ros_type_name

class Type:
    """
    Represents a data type. Constructed from a ROS type string.
    Produces Flatbuffers type strings.
    """
    def __init__(self, ros_type):
        match = re.match(r"^(?:([\w\/]+)\/)?(\w+)(\[\d*\])?$", ros_type)
        self.ros_type = ros_type
        if match.group(1) is not None:
            self.namespace = match.group(1).replace("/", ".")
        else:
            self.namespace = None
        self.name = match.group(2)
        self.is_array = match.group(3) is not None
    
    def fbs_type_name(self):
        """ Fully qualified Flatbuffers type name with remapping """
        if self.namespace is not None:
            n = "{}.{}".format(self.namespace, self.name)
        else: 
            n = self.name
        return type_remap(n)
    
    def fbs_type(self):
        """ Fully qualified Flatbuffers type with remapping """
        full_name = self.fbs_type_name()
        if self.is_array:
            return "[{}]".format(full_name)
        return full_name

    def is_defined(self, defined_types):
        """ Determine whether this type has been defined for Flatbuffers """
        return self.fbs_type_name() in defined_types

def gen_table(msg_type, items, defined_types, *, args):
    """ Generate a table for given name, type pairs. """
    yield "table {} {{".format(msg_type.name)
    yield from gen_metadata_item(args=args)
    for k, v in items:
        yield "  {}:{};".format(k, v.fbs_type())
    yield "}"

def gen_constants_enums(msg_type: Type):
    """
    Generate enums to represent ROS message constants.

    Enums are Flatbuffers' closest approximation of constants. We generate one
    enum per constant, with a single field "value". Only integer types are 
    supported by Flatbuffers.
    """

    from msg_util import get_msg_spec # in case the module breaks, don't break this whole script
    spec = get_msg_spec(msg_type.ros_type)
    # https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html
    allowed_enum_types = {"int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64"}
    for c in spec.constants:
        if c.type in allowed_enum_types:
            yield "enum {} : {} {{ value = {} }}".format(c.name, c.type, c.val)

def gen_constants_table(msg_type: Type):
    """
    Generate a table with default values to represent ROS message constants.
    Using generated Flatbuffers code, this table should be constructed as a 
    singleton to read constants values.

    The table is named MsgTypeConstants, where MsgType is the name of the given
    message type.
    
    The advantage of this method over enums is that it supports any ROS 
    constant type.
    """ 

    from msg_util import get_msg_spec # in case the module breaks, don't break this whole script
    spec = get_msg_spec(msg_type.ros_type)
    yield "table {}Constants {{".format(msg_type.name)
    for c in spec.constants:
        t = Type(c.type)
        if t.fbs_type() in primitive_types:
            yield "  {}:{} = {};".format(c.name, t.fbs_type(), c.val_text)
    yield "}"

def gen_msg(msg_type, defined_types, *, args):
    """ 
    Generate .fbs definitions for a ROS message type, including dependencies. 
    """

    # no need to generate already-defined type
    if msg_type.is_defined(defined_types):
        raise RuntimeError("Type already generated: {}".format(msg_type.ros_type))
    defined_types.add(msg_type.fbs_type_name())

    msg_class = get_message_class(msg_type.ros_type)

    # this is officially suggested by http://wiki.ros.org/msg#Client_Library_Support
    name = msg_class._type
    keys = msg_class.__slots__
    types = [Type(name) for name in msg_class._slot_types]

    # generate dependency types
    for t in types:
        if not t.is_defined(defined_types):
            yield from gen_msg(t, defined_types, args=args)
    
    # generate type definition
    yield "namespace {};".format("{}.{}".format(args.base_namespace, msg_type.namespace))
    if args.gen_enums:
        yield from gen_constants_enums(msg_type)
    if args.gen_constants:
        yield from gen_constants_table(msg_type)
    yield from gen_table(msg_type, zip(keys, types), defined_types, args=args)

def generate_schema(msg_type_names, *, args):
    """ Generate Flatbuffers .fbs schema for several ROS message types, including dependencies. """
    defined_types = set(base_defined_types)
    yield from gen_support(args=args)
    for msg_type_name in msg_type_names:
        yield from gen_msg(Type(msg_type_name), defined_types, args=args)

if __name__ == "__main__":
    ap = ArgumentParser("msg2fbs.py", description=__doc__)
    ap.add_argument("message_type", nargs="+",
        help="ROS names specifying which messages to generate (e.g. std_msgs/String)")
    ap.add_argument("--output-file", "-o", nargs="?", default=None,
        help="Specify an output file. Otherwise, the schema is written to stdout.")
    ap.add_argument("--base-namespace", "-n", nargs="?", default="fb", type=str,
        help="Base namespace for Flatbuffers types, to avoid collisions with ROS types.")
    ap.add_argument("--gen-enums", "-e", action="store_true",
        help="Generate (un)signed integer-type ROS message constants as enums")
    ap.add_argument("--gen-constants", "-c", action="store_true",
        help="Generate ROS message constants as tables with default values")
    ns = ap.parse_args()
    
    if ns.output_file is None:
        output_file = sys.stdout
    else:
        output_file = open(ns.output_file, "w+")
    
    lines = generate_schema(ns.message_type, args=ns)
    output_file.writelines(line + os.linesep for line in lines)
    output_file.close()
